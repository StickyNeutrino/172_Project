{"version":3,"file":"twitter.js","sources":["../twitter.js"],"sourcesContent":["const crypto = require('crypto');\nconst OAuth = require('oauth-1.0a');\nconst Fetch = require('cross-fetch');\nconst querystring = require('querystring');\nconst Stream = require('./stream');\n\nconst getUrl = (subdomain, endpoint = '1.1') =>\n  `https://${subdomain}.twitter.com/${endpoint}`;\n\nconst createOauthClient = ({ key, secret }) => {\n  const client = OAuth({\n    consumer: { key, secret },\n    signature_method: 'HMAC-SHA1',\n    hash_function(baseString, key) {\n      return crypto\n        .createHmac('sha1', key)\n        .update(baseString)\n        .digest('base64');\n    },\n  });\n\n  return client;\n};\n\nconst defaults = {\n  subdomain: 'api',\n  consumer_key: null,\n  consumer_secret: null,\n  access_token_key: null,\n  access_token_secret: null,\n  bearer_token: null,\n};\n\n// Twitter expects POST body parameters to be URL-encoded: https://developer.twitter.com/en/docs/basics/authentication/guides/creating-a-signature\n// However, some endpoints expect a JSON payload - https://developer.twitter.com/en/docs/direct-messages/sending-and-receiving/api-reference/new-event\n// It appears that JSON payloads don't need to be included in the signature,\n// because sending DMs works without signing the POST body\nconst JSON_ENDPOINTS = [\n  'direct_messages/events/new',\n  'direct_messages/welcome_messages/new',\n  'direct_messages/welcome_messages/rules/new',\n];\n\nconst baseHeaders = {\n  'Content-Type': 'application/json',\n  Accept: 'application/json',\n};\n\nfunction percentEncode(string) {\n  // From OAuth.prototype.percentEncode\n  return string\n    .replace(/!/g, '%21')\n    .replace(/\\*/g, '%2A')\n    .replace(/'/g, '%27')\n    .replace(/\\(/g, '%28')\n    .replace(/\\)/g, '%29');\n}\n\nclass Twitter {\n  constructor(options) {\n    const config = Object.assign({}, defaults, options);\n    this.authType = config.bearer_token ? 'App' : 'User';\n    this.client = createOauthClient({\n      key: config.consumer_key,\n      secret: config.consumer_secret,\n    });\n\n    this.token = {\n      key: config.access_token_key,\n      secret: config.access_token_secret,\n    };\n\n    this.url = getUrl(config.subdomain);\n    this.oauth = getUrl(config.subdomain, 'oauth');\n    this.config = config;\n  }\n\n  /**\n   * Parse the JSON from a Response object and add the Headers under `_headers`\n   * @param {Response} response - the Response object returned by Fetch\n   * @return {Promise<object>}\n   * @private\n   */\n  static _handleResponse(response) {\n    const headers = response.headers.raw(); // TODO: see #44\n    // Return empty response on 204 \"No content\"\n    if (response.status === 204)\n      return {\n        _headers: headers,\n      };\n    // Otherwise, parse JSON response\n    return response.json().then(res => {\n      res._headers = headers; // TODO: this creates an array-like object when it adds _headers to an array response\n      return res;\n    });\n  }\n\n  async getBearerToken() {\n    const headers = {\n      Authorization:\n        'Basic ' +\n        Buffer.from(\n          this.config.consumer_key + ':' + this.config.consumer_secret\n        ).toString('base64'),\n      'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8',\n    };\n\n    const results = await Fetch('https://api.twitter.com/oauth2/token', {\n      method: 'POST',\n      body: 'grant_type=client_credentials',\n      headers,\n    }).then(Twitter._handleResponse);\n\n    return results;\n  }\n\n  async getRequestToken(twitterCallbackUrl) {\n    const requestData = {\n      url: `${this.oauth}/request_token`,\n      method: 'POST',\n    };\n\n    let parameters = {};\n    if (twitterCallbackUrl) parameters = { oauth_callback: twitterCallbackUrl };\n    if (parameters) requestData.url += '?' + querystring.stringify(parameters);\n\n    const headers = this.client.toHeader(\n      this.client.authorize(requestData, {})\n    );\n\n    const results = await Fetch(requestData.url, {\n      method: 'POST',\n      headers: Object.assign({}, baseHeaders, headers),\n    })\n      .then(res => res.text())\n      .then(txt => querystring.parse(txt));\n\n    return results;\n  }\n\n  async getAccessToken(options) {\n    const requestData = {\n      url: `${this.oauth}/access_token`,\n      method: 'POST',\n    };\n\n    let parameters = { oauth_verifier: options.verifier };\n    if (parameters) requestData.url += '?' + querystring.stringify(parameters);\n\n    const headers = this.client.toHeader(\n      this.client.authorize(requestData, {\n        key: options.key,\n        secret: options.secret,\n      })\n    );\n\n    const results = await Fetch(requestData.url, {\n      method: 'POST',\n      headers: Object.assign({}, baseHeaders, headers),\n    })\n      .then(res => res.text())\n      .then(txt => querystring.parse(txt));\n\n    return results;\n  }\n\n  /**\n   * Construct the data and headers for an authenticated HTTP request to the Twitter API\n   * @param {string} method - 'GET' or 'POST'\n   * @param {string} resource - the API endpoint\n   * @param {object} parameters\n   * @return {{requestData: {url: string, method: string}, headers: ({Authorization: string}|OAuth.Header)}}\n   * @private\n   */\n  _makeRequest(method, resource, parameters) {\n    const requestData = {\n      url: `${this.url}/${resource}.json`,\n      method,\n    };\n    if (parameters)\n      if (method === 'POST') requestData.data = parameters;\n      else requestData.url += '?' + querystring.stringify(parameters);\n\n    let headers = {};\n    if (this.authType === 'User') {\n      headers = this.client.toHeader(\n        this.client.authorize(requestData, this.token)\n      );\n    } else {\n      headers = {\n        Authorization: `Bearer ${this.config.bearer_token}`,\n      };\n    }\n    return {\n      requestData,\n      headers,\n    };\n  }\n\n  /**\n   * Send a GET request\n   * @param {string} resource - endpoint, e.g. `followers/ids`\n   * @param {object} [parameters] - optional parameters\n   * @returns {Promise<object>} Promise resolving to the response from the Twitter API.\n   *   The `_header` property will be set to the Response headers (useful for checking rate limits)\n   */\n  get(resource, parameters) {\n    const { requestData, headers } = this._makeRequest(\n      'GET',\n      resource,\n      parameters\n    );\n\n    return Fetch(requestData.url, { headers })\n      .then(Twitter._handleResponse)\n      .then(results =>\n        'errors' in results ? Promise.reject(results) : results\n      );\n  }\n\n  /**\n   * Send a POST request\n   * @param {string} resource - endpoint, e.g. `users/lookup`\n   * @param {object} body - POST parameters object.\n   *   Will be encoded appropriately (JSON or urlencoded) based on the resource\n   * @returns {Promise<object>} Promise resolving to the response from the Twitter API.\n   *   The `_header` property will be set to the Response headers (useful for checking rate limits)\n   */\n  post(resource, body) {\n    const { requestData, headers } = this._makeRequest(\n      'POST',\n      resource,\n      JSON_ENDPOINTS.includes(resource) ? null : body // don't sign JSON bodies; only parameters\n    );\n\n    const postHeaders = Object.assign({}, baseHeaders, headers);\n    if (JSON_ENDPOINTS.includes(resource)) {\n      body = JSON.stringify(body);\n    } else {\n      body = percentEncode(querystring.stringify(body));\n      postHeaders['Content-Type'] = 'application/x-www-form-urlencoded';\n    }\n\n    return Fetch(requestData.url, {\n      method: 'POST',\n      headers: postHeaders,\n      body,\n    })\n      .then(Twitter._handleResponse)\n      .then(results =>\n        'errors' in results ? Promise.reject(results) : results\n      );\n  }\n\n  /**\n   *\n   * @param {string} resource - endpoint, e.g. `statuses/filter`\n   * @param {object} parameters\n   * @returns {Stream}\n   */\n  stream(resource, parameters) {\n    if (this.authType !== 'User')\n      throw new Error('Streams require user context authentication');\n\n    const stream = new Stream();\n\n    // POST the request, in order to accommodate long parameter lists, e.g.\n    // up to 5000 ids for statuses/filter - https://developer.twitter.com/en/docs/tweets/filter-realtime/api-reference/post-statuses-filter\n    const requestData = {\n      url: `${getUrl('stream')}/${resource}.json`,\n      method: 'POST',\n    };\n    if (parameters) requestData.data = parameters;\n\n    const headers = this.client.toHeader(\n      this.client.authorize(requestData, this.token)\n    );\n\n    const request = Fetch(requestData.url, {\n      method: 'POST',\n      headers: {\n        ...headers,\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: percentEncode(querystring.stringify(parameters)),\n    });\n\n    request\n      .then(response => {\n        stream.destroy = this.stream.destroy = () => response.body.destroy();\n\n        if (response.ok) {\n          stream.emit('start', response);\n        } else {\n          response._headers = response.headers.raw();  // TODO: see #44 - could omit the line\n          stream.emit('error', response);\n        }\n\n        response.body\n          .on('data', chunk => stream.parse(chunk))\n          .on('error', error => stream.emit('error', error))  // no point in adding the original response headers\n          .on('end', () => stream.emit('end', response));\n      })\n      .catch(error => stream.emit('error', error));\n\n    return stream;\n  }\n}\n\nmodule.exports = Twitter;\n"],"names":["const","crypto","require","OAuth","Fetch","querystring","Stream","getUrl","subdomain","endpoint","defaults","consumer_key","consumer_secret","access_token_key","access_token_secret","bearer_token","JSON_ENDPOINTS","baseHeaders","Content-Type","Accept","percentEncode","string","replace","Twitter","options","ref","config","Object","assign","authType","client","consumer","signature_method","hash_function","baseString","key","createHmac","update","digest","token","url","oauth","_handleResponse","response","headers","raw","status","json","then","res","_headers","getBearerToken","Buffer","from","this","toString","$await_1","getRequestToken","twitterCallbackUrl","parameters","requestData","stringify","toHeader","authorize","text","txt","parse","$await_2","getAccessToken","verifier","secret","$await_3","_makeRequest","method","resource","data","get","results","Promise","reject","post","body","includes","postHeaders","JSON","stream","Error","destroy","ok","emit","on","chunk","error","catch","module","exports"],"mappings":"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"}